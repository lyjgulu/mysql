## mysql事务(InnoDB)

### 事务基本点
1. 事务的特性
    - ACID(原子性、一致性、隔离性、持久性)
2. 四种隔离级别
    - 读未提交：脏读，不可重复读，幻读
    - 读已提交：不可重复读，幻读
    - 可重复读：幻读(Next-Key lock解决)
    - 可串行化：无问题(一般不使用该隔离级别)
      **不可重复读的重点是修改，幻读的重点在于新增或者删除。**

3. 数据库里面会创建一个视图(快照读)，访问的时候以视图的逻辑结果为准。
    - 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 
    - 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。
    - “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念。
    - 而“串行化”隔离级别下直接用加锁(当前读)的方式来避免并行访问。
   
### MVCC(undo log部分看mysql的各种log)
- MVCC适用于读提交与可重复读的隔离级别
    1. 读提交在每个SQL语句开始执行的时候创建快照。(read view)
    2. 可重复读在事务启动时创建唯一快照。(reda view)
    3. **更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”。（current read）**
- 判断trx_ids方法
![transactionId](https://raw.githubusercontent.com/lyjgulu/mysql/main/image/transactionId.png)

- PostgreSQL与MySQL在MVCC实现上的区别(扩展点)
   - MySQL采用MVCC与悲观锁(Next-Key lock)结合。(具体看mysql锁机制)
      - 所有DDL的sql语句会分配唯一id(回滚id)，读操作依据当前事务的可见trx_id(//TODO)
   - PostgreSQL采用MVCC与乐观锁结合
      - 所有的事务在执行之前都会被分配一个唯一的时间戳，每一个数据项都有读写两个时间戳。
      - 不阻塞读请求，直接返回最新值。
      - 写操作在执行时，事务的时间戳一定要大或者等于数据行的读时间戳，否则就会被回滚。
