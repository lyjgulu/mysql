## SQL执行过程

### 写操作执行过程

//todo 图片

### 相关组件

#### 1、连接器

- 客户端与服务端通信为半双工模式，某一固定时刻只能由客户端向服务器请求或者服务器向客户端发送数据，而不能同时进行。(tcp协议为全双工，数据可以在两个方向上同时传递，4次挥手是因为tcp的半关闭造成)
- 验证用户名和密码是否正确，如果正确，则会去 mysql 的权限表（mysql中的 user、db、columns_priv、Host 表，分别存储的是全局级别、数据库级别、表级别、列级别、配合 db 的数据库级别）查询当前用户的权限。

#### 2、缓存(不重要，省略)

#### 3、分析器

- 抛出语法错误都在分析器层面。
- 对客户端传来的 sql 进行分析，这将包括预处理与解析过程，并进行关键词的提取、解析，并组成一个解析树。

#### 4、优化器
- 优化器会根据执行计划选择最优的选择，匹配合适的索引，选择最佳的方案。
// todo explain sql 

- 优化器会根据扫描行数、是否使用临时表、是否排序等来判断是否使用某个索引，其中扫描行数的计算可以通过统计信息来估算得出，而统计信息可以看作是索引唯一数的数量，可以使用部分采样来估算，具体就是选择 N 个数据页，统计这些页上数据的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了。但是因为索引数据会变化，所以索引的统计信息也会变化。当变更的数据行数超过 1/M 的时候，就会重新计算一次统计信息。

1. 没有使用最优索引优化问题
    1. 虽然会自动更新统计信息，但是但是不能保证统计信息是最新值，这就可能导致优化器选择了不同的索引导致执行变慢，所以可以通过 " analyze  table 表名" 来重新计算索引的统计信息。
    2. 在表名后面添加 " force index(索引名) " 语句来强制使用索引。(一般不推荐使用)
    3. 将 sql 进行修改成优化器可以选最优索引的实现方式。(推荐使用)
    4. 新建一个最优索引或者删除优化器误用的索引。

#### 执行器(不重要，省略)

### 存储引擎层(InnoDB)

#### 三种日志

#### undo log 与 MVCC(并发版本控制)

- undo log是 Innodb 引擎专属的日志，是记录每行数据事务执行前的数据。主要作用是用于实现MVCC版本控制，undo log保证事务隔离级别的读已提交和读未提交级别，保证了原子性。(幻读问题依靠锁来实现)
#### redo log 与 Buffer Pool
- nnoDB 内部维护了一个缓冲池，用于减少对磁盘数据的直接IO操作，并配合 redo log、内部的 change buffer 来实现异步的落盘，保证程序的高效执行。
- redo log 是记录修改操作，防止断电丢失写操作，降低随机写消耗（转成顺序写）；Change Buffer 是为了将写操作延迟更新到缓冲池，降低随机读的消耗（不需要频繁从磁盘读数据页)
- //todo 图片
#### bin log(所有引擎都有)
- redo log 因为大小固定，所以不能存储过多的数据，它只能用于未更新的数据落盘，而数据操作的备份恢复、以及主从复制是靠 bin log。（如果数据库误删需要还原，那么需要某个时间点的数据备份以及bin log）
- 在更新到数据页缓存或者Change Buffer后，首先进行redo log的编写，编写完成后将 redo log设为prepare状态，随后再进行binlog的编写，等到binlog也编写完成后再将redo log设置为commit状态。这是为了防止数据库宕机导致binlog没有将修改记录写入，后面数据恢复、主从复制时数据不一致。
- 断电回滚
    先检查redo log记录的事务操作是否为commit状态：1、如果是commit状态说明没有数据丢失，判断下一个。2、如果是prepare状态，检查binlog记录的对应事务操作（redo log 与 binlog 记录的事务操作有一个共同字段XID，redo log就是通过这个字段找到binlog中对应的事务的）是否完整（这点在前面 binlog三种格式分析过，每种格式记录的事务结尾都有特定的标识），如果完整就将redo log设为commit状态，然后结束；不完整就回滚redo log的事务，结束。
- 三种日志格式
    1.Row（5.7默认）。记录操作语句对具体行的操作以及操作前的整行信息。缺点是占空间大。优点是能保证数据安全，不会发生遗漏。
    2.Statement。记录修改的 sql。缺点是在 mysql 集群时可能会导致操作不一致从而使得数据不一致（比如在操作中加入了Now()函数，主从数据库操作的时间不同结果也不同）。优点是占空间小，执行快。
    3.Mixed。会针对于操作的 sql 选择使用Row 还是 Statement。缺点是还是可能发生主从不一致的情况。

#### 三种日志的比较
1. undo log是用于事务的回滚、保证事务隔离级别读已提交、可重复读实现的。redo log是用于对暂不更新到磁盘上的操作进行记录，使得其可以延迟落盘，保证程序的效率。bin log是对数据操作进行备份恢复（并不能依靠 bin log 直接完成数据恢复）。

2. undo log 与 redo log 是存储引擎层的日志，只能在 InnoDB 下使用；而bin log 是 Server 层的日志，可以在任何引擎下使用。

3. redo log 大小有限，超过后会循环写；另外两个大小不会。

4. undo log 记录的是行记录变化前的数据；redo log 记录的是 sql 的数据页修改逻辑以及 change buffer 的变更；bin log记录操作语句对具体行的操作以及操作前的整行信息（5.7默认）或者sql语句。

5. 单独的 binlog 没有 crash-safe 能力，也就是在异常断电后，之前已经提交但未更新的事务操作到磁盘的操作会丢失，也就是主从复制的一致性无法保障，而 redo log 有 crash-safe 能力，通过与 redo log 的配合实现 "三步提交"，就可以让主从库的数据也能保证一致性。

6. redo log 是物理日志，它记录的是数据页修改逻辑以及 change buffer 的变更，只能在当前存储引擎下使用，而 binlog 是逻辑日志，它记录的是操作语句涉及的每一行修改前后的值，在任何存储引擎下都可以使用。
   
   **MySQL 是 WAL（Write-Ahead Logging）机制，也就是写操作会先存入日志，然后再写入磁盘，这样可以避开高峰，提高数据库的可用性。**

### 索引下推(理解，暂未放图)
1. Index Key
	查询语句中用到的索引列放在Index Key中。
2. Index Filter
	查询语句中未用到索引列但该列上有存在索引放在Index Filter中。
3. Table Filter
	查询语句中没有索引的列放在Table Filter中。

### SQL执行顺序
// todo 图