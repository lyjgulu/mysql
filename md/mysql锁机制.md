## 事务原理和锁机制

1. 事务的特性
	- ACID(原子性、一致性、隔离性、持久性)
2. 四种隔离级别
	- 读未提交：脏读，不可重复读，幻读
	- 读已提交：不可重复读，幻读
	- 可重复读：幻读
	- 可串行化：无问题(一般不使用该隔离级别)
	**不可重复读的重点是修改，幻读的重点在于新增或者删除。**

### mysql中的锁

#### 按颗粒度划分
1. 行级锁
	- 对一行数据加锁，当一个事务操作某一行事务时，只对该行数据加排他锁时，其他事务对其他行数据操作时不会影响，并发性好。缺点是在加多条数据时加锁会比较耗时。
2. 表级锁(两种)
	- MDL，是 DDL 操作与 DML、DQL 操作冲突的加锁。(表操作与增删改，查操作冲突)
	- 对整张表进行加读写锁，仅针对 DML、DQL 操作。加锁快但是可承受的并发量低。 
		- 加读锁：lock table 表名  read ;  加写锁：lock  tables  表名  write ;  释放读写锁：unlock  tables;
3. 全局锁
	- 对所有表所有数据进行加锁。这个锁是读锁，也就是加锁后当前数据库只能处理读操作，不能处理写操作。一般在将整个库的数据进行逻辑备份时使用（**在 InnoDB 中可以使用 mysqldump 进行非阻塞式备份，原理就是通过 隔离级别MVCC数据一致性实现的**）。　　　　
	- 加锁： Flush tables with read lock (FTWRL)
4. 页级锁
	- 对一页数据进行加锁，介于行级锁与表级锁之间。
#### 按种类划分
1. 共享锁（读锁）S锁
	- 共享锁是对于MySQL中的读操作的，所以共享锁也叫读锁，一个事务进行读操作时，会对读取的数据添加读锁（**可串行化下的读操作是自动加锁的，其他隔离级别需要在查询语句后面添加 lock in share mode**），加锁后其他事务也可以对加锁的数据进行读取。**获取了某记录的共享锁后只能对其进行读取，不能修改，也不能去读取其他表的数据**
2. 排他锁（写锁）X锁
	- 排它锁是对于 MySQL 中的写操作的，所以排它锁也叫写锁。添加排它锁的数据其他事务就不能进行操作，同时共享锁与排它锁也是互斥的，也就是一个事务对某数据添加了共享锁，那么其他事务就不能对其再添加排它锁。**在所有隔离级别级别中的修改操作（insert、update、delete）都会添加排他锁，而读操作可以通过在语句后面添加 for update 来对读取的数据添加排它锁。**
#### 其他种类
1. Record Lock
	- 记录锁。**record lock 是加在具体记录对应聚簇索引上的锁，它是锁住的是索引本身而不是记录**，如果该表没有聚簇索引，也会创建一个聚簇索引来代替。换句话说 record lock 属于行级锁。它既可以是共享锁也可以是排它锁（究竟是共享锁还是排他锁上面已经分析了）。任何级别都会存在。
2. Gap Lock
	- 间隙锁，就是加在两条数据索引之间的锁，比如数据表student(id,name)，id 是主键，有数据(5,"aa"),(7,"bb")，隔离级别是可串行化。此时事务1执行select * from student where id>5 and id<7，那么就会对 (4,7) 添加间隙锁，锁住中间的间隙。比如说事务2执行insert into(6,"cc")，那么次操作就会被阻塞。**在可重复读及以上级别才会有。间隙锁是一种共享锁，多个事务可以对同一个间隙添加间隙锁。**
3. Next-Key Lock
	- 指的是 Record Lock 与 Gap Lock 的结合。针对 Gap Lock 中的例子，如果事务1执行的是 select * from dept where id>4 and id<8，那么对数据(5,"aa")、(7,"bb")对应的聚簇索引上也会添加 Record Lock。同时(4,5),(5,7),(7,8)也会加上间隙锁。同 Gap Lock 一样，只有可重复读以以上级别才会出现。**next-key lock 都是 “左开右闭” 的**，也就是以前面的事务1来举例，会添加的锁依次是：net-key lock (4,5]、(5,6]、(6,7]，间隙锁(7,8)。 
4. MDL（MetaData  Lock）
	- 后面补充的 Lock，其本质属于表级锁，在数据增删改和表结构变化时自动进行加锁、解锁，增删改操作会加读锁，修改表结构会加写锁。
5. 自增锁
	- 主键id自增