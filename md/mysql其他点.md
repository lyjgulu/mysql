## mysql其他点

### 写操作执行过程

![执行过程](https://raw.githubusercontent.com/lyjgulu/mysql/main/image/sqlExecutionProcess.jpg)

### 相关组件

#### 1、连接器

- 客户端与服务端通信为半双工模式，某一固定时刻只能由客户端向服务器请求或者服务器向客户端发送数据，而不能同时进行。(tcp协议为全双工，数据可以在两个方向上同时传递，4次挥手是因为tcp的半关闭造成)
- 验证用户名和密码是否正确，如果正确，则会去 mysql 的权限表（mysql中的 user、db、columns_priv、Host 表，分别存储的是全局级别、数据库级别、表级别、列级别、配合 db 的数据库级别）查询当前用户的权限。

#### 2、缓存(不重要，省略)

#### 3、分析器

- 抛出语法错误都在分析器层面。
- 对客户端传来的 sql 进行分析，这将包括预处理与解析过程，并进行关键词的提取、解析，并组成一个解析树。

#### 4、优化器
- 优化器会根据执行计划选择最优的选择，匹配合适的索引，选择最佳的方案。
![explain](https://raw.githubusercontent.com/lyjgulu/mysql/main/image/expain%20sql.png)
- 优化器会根据扫描行数、是否使用临时表、是否排序等来判断是否使用某个索引，其中扫描行数的计算可以通过统计信息来估算得出，而统计信息可以看作是索引唯一数的数量，可以使用部分采样来估算，具体就是选择 N 个数据页，统计这些页上数据的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了。但是因为索引数据会变化，所以索引的统计信息也会变化。当变更的数据行数超过 1/M 的时候，就会重新计算一次统计信息。

1. 没有使用最优索引优化问题
    1. 虽然会自动更新统计信息，但是但是不能保证统计信息是最新值，这就可能导致优化器选择了不同的索引导致执行变慢，所以可以通过 " analyze  table 表名" 来重新计算索引的统计信息。
    2. 在表名后面添加 " force index(索引名) " 语句来强制使用索引。(一般不推荐使用)
    3. 将 sql 进行修改成优化器可以选最优索引的实现方式。(推荐使用)
    4. 新建一个最优索引或者删除优化器误用的索引。

#### 执行器(不重要，省略)

### count使用
- 由于多版本并发控制(MVCC),返回的行数是无法确定的
![count计数](https://raw.githubusercontent.com/lyjgulu/mysql/main/image/count%20number.png)

- 优化器会找到最小的索引树去遍历。**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**(普通索引树比主键索引树小很多)

- 使用缓存技术(需要类似于分布式事务机制来保障)

### 不同count性能
- count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。
  
- 分析性能差别的原则
    1. server层要什么就给什么；
    2. InnoDB只给必要的值；
    3. 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。
  
- count(主键id)
    - InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。

- count(1)
    - InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
  
- count(字段)
    1. 字段定义为 not null ，一行行从记录里面读出字段，判断不能为 null ，按行累加。
    2. 字段定义为 null ，执行时，判断有可能是null，再把值取出来判断，不是 null 累加。
 
- count(*)
    - mysql专门优化，可以直接使用。
    
### Online DDL
