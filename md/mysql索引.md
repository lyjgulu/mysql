## mysql索引

### InnoDB 索引物理结构
- 正常采用 B+ tree 结构存储，空间索引(地理坐标，多边形)采用 R tree 结构存储，默认为16KB
- 新记录插入到聚簇索引中时，InnoDB会尝试留出 1/16 页空闲空间来应对插入或更新数据，一般采用顺序插入时，生成的索引大小为 15/16。

### 常见的索引模型
1. 哈希表(类似Java中的HashMap)
    - 适用于等值查询的场景
2. 有序数组(等值查询和范围查询场景性能优秀，更新数据时复杂度较高)
    - 适用于静态存储引擎(静态数据)
3. 二叉搜索树
    - 查询实践复杂度O(log(N))，更新复杂度O(log(N))
4. N叉树(优化二叉树磁盘随机读写问题，适配磁盘的访问模式)

### InnoDB 的索引模型
1. B 树
    - 每个节点最多有 m 个孩子。
    - 每个非叶节点（根除外）至少有 ⌈ m / 2 ⌉ 个子节点。
    - 如果根不是叶节点，则根至少有两个子节点。
    - 一个有 k 个孩子的非叶节点包含 k − 1 个键。
    - 所有叶子都出现在同一级别并且不携带任何信息。
2. B+ 树(InnoDB)
    - B+ 树元素自底向上插入。
    - 如果此B+树的阶数是m，则除了根之外的每个节点都包含最少 [ m / 2 ]个元素最多 [ m - 1 ] 个元素，对于任意的结点有最多 m 个子指针。
    - 对于所有内部节点，子指针的数目总是比元素的数目多一个。
    - 所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。
    - 叶子节点有双向指针

### 索引类型

1. 主键索引(聚簇索引，一级索引)
    - 叶子节点存的是整行数据

2. 非主键索引(普通索引，二级索引)
    - 叶子节点内容是主键的值

3. 唯一索引
    - 保证数据不重复

4. 复合索引
    - 减少搜索次数

5. 覆盖索引(特殊复合索引)
    - 减少搜索次数，同时不需要回表

### 索引维护   
1. 插入数据时，如果插入主键索引不是递增，会造成页分裂的情况，降低性能企鹅影响数据叶的利用率
2. 删除数据时，也会出现叶合并的情况

### 索引最左前缀原则
**注意** 优化器会sql语句进行优化来适应最左前缀原则

### 索引下推
1. Index Key
   查询语句中用到的索引列放在Index Key中。(**使用like或区间查询或其他条件会使得复合索引后半部分失效**)
2. Index Filter
   查询语句中未用到索引列但该列上有存在索引放在Index Filter中。(**复合索引失效部分**)
3. Table Filter
   查询语句中没有索引的列放在Table Filter中。

### 普通索引和唯一索引的对比
1. 查询过程(性能差距不大)
    - 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。
    - 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
    - 原因：InnoDB的数据在物理层面是按数据页为单位来读写的，以页( 16 KB )为单位，将其整体读入内存( Buffer Pool )
2. 更新过程(推荐普通索引)
    - 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。更新不使用 change buffer。
    - 对于普通索引来说，更新使用 change buffer 。
    - 两种情况
        1. 这个记录要更新的目标页在内存中
            - 对于唯一索引来说，找到正确的位置，判断到没有冲突，插入这个值，语句执行结束。
            - 对于普通索引来说，找到正确的位置，插入这个值，语句执行结束。
        2. 这个记录要更新的目标页不在内存中
            - 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
            - 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。
3. 一些问题的权衡及排查
    - 业务正确性优先，无法保证不写入重复数据使用唯一索引。
    - 出现大量插入数据慢、内存命中率低时，可能时唯一索引造成。
    - 一些归档或不改动的历史数据可以选择使用唯一索引

### 优化器选择索引的逻辑(**扫描行数**，是否使用临时文件，是否排序)
1. mysql得到索引基数(采样统计)
    - 采样统计：默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。当变更的数据行数超过1/M的时候，会自动触发重新做一次索引统计。
    - 采样统计两种存储方式，通过设置参数innodb_stats_persistent的值来选择
        - 设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。
        - 设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。
2. 优化器预估的扫描行数
![scanningCount](https://raw.githubusercontent.com/lyjgulu/mysql/main/image/scanningCount.png)
    - 虽然索引a扫描行数较少，但有回表操作
3. 扫描行数错误可能的原因
    1. **场景题** session A执行事务，让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001变成37000多。单独执行session B的操作，看到rows字段其实还是10000左右。
        - mysql对记录的删除操作采用标记删除的办法，不在索引以及数据文件中真正的删除，delete 和 insert 中间间隔较小时，purge线程没有来得及清理该记录，如果主键相同，新插入数据会沿用之前空间。使得统计信息没有变化，rows显示10000左右。
        - session A开启的事务对session B的delete操作后的索引数据的统计时效产生了影响，因为需要保证事务A的重复读，在数据页没有实际删除，而索引的统计选择了N个数据页，这部分数据页不收到前台事务的影响，所以整体统计值会变大，直接影响了索引选择的准确性，导致rows显示30000左右。
4. 解决方案
    1. 虽然会自动更新统计信息，但是但是不能保证统计信息是最新值，这就可能导致优化器选择了不同的索引导致执行变慢，所以可以通过 " analyze  table 表名" 来重新计算索引的统计信息。 
    2. 在表名后面添加 " force index(索引名) " 语句来强制使用索引。(一般不推荐使用)
    3. 将 sql 进行修改成优化器可以选最优索引的实现方式。(推荐使用)
    4. 新建一个最优索引或者删除优化器误用的索引。
  
### 给字符串字段加索引
1. 使用前缀索引，定义合数的长度，可以做到既省空间，又可以不用额外增加太多的查询成本。
2. 前缀索引对覆盖索引的影响，使用前缀索引就用不覆盖索引对查询性能的优化。
3. 一些使用前缀索引的特殊处理方式
    - 使用倒序存储，使用hash字段
    - 区别：
        1. 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。
        2. 在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。
        3. 从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。
4. 总结
    1. 直接创建完整索引，这样可能比较占用空间；
    2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
    3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；     
    4. 创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。
    
### 构建排序索引(仅支持 InnoDB 的 b+ tree)
- 构建的三个阶段：
    1. 扫描聚簇索引，生成索引条目写入 sort buffer(详见 buffer详解)，buffer 满时，写入 sort file。
    2. 一次或多次写入临时文件，进行归并排序。
    3. 插入到新的 b+ tree 中。
- 禁止写 redo log(详见 log篇)，强制将脏页写入磁盘。